#!/usr/bin/env node

/**
 * Updates frontmatter in local ocobo-posts repository to use Vercel Blob URLs
 * Prerequisites: git clone the ocobo-posts repository locally
 * Run: node scripts/update-frontmatter-local.js /path/to/ocobo-posts
 */

import { dirname, join } from 'path';
import { fileURLToPath } from 'url';
import { readFile, readdir, stat, writeFile } from 'fs/promises';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Load the asset URL mapping generated by migrate-to-blob.js
const mappingPath = join(__dirname, 'asset-url-mapping.json');

async function loadUrlMapping() {
  try {
    const mappingData = await readFile(mappingPath, 'utf-8');
    return JSON.parse(mappingData);
  } catch (error) {
    console.error('‚ùå Failed to load URL mapping file:', error.message);
    console.log(
      'Make sure to run migrate-to-blob.js first to generate the mapping file',
    );
    process.exit(1);
  }
}

function updateMarkdownContent(content, urlMapping) {
  let updatedContent = content;
  let replacements = 0;

  // Update image references in frontmatter and content
  for (const [oldUrl, newUrl] of Object.entries(urlMapping)) {
    // Create patterns to match both relative and absolute URLs
    const relativePath = oldUrl.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const absolutePattern = `https://www\\.ocobo\\.co${relativePath.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}`;

    // Replace absolute URLs first (https://www.ocobo.co/posts/...)
    const absoluteRegex = new RegExp(absolutePattern, 'g');
    const absoluteMatches = updatedContent.match(absoluteRegex);
    if (absoluteMatches) {
      updatedContent = updatedContent.replace(absoluteRegex, newUrl);
      replacements += absoluteMatches.length;
    }

    // Then replace relative URLs (/posts/...)
    const relativeRegex = new RegExp(relativePath, 'g');
    const relativeMatches = updatedContent.match(relativeRegex);
    if (relativeMatches) {
      updatedContent = updatedContent.replace(relativeRegex, newUrl);
      replacements += relativeMatches.length;
    }
  }

  return { content: updatedContent, replacements };
}

async function findMarkdownFiles(dirPath) {
  const files = [];

  try {
    const entries = await readdir(dirPath);

    for (const entry of entries) {
      const fullPath = join(dirPath, entry);
      const stats = await stat(fullPath);

      if (stats.isDirectory()) {
        // Recursively search subdirectories
        const subFiles = await findMarkdownFiles(fullPath);
        files.push(...subFiles);
      } else if (entry.endsWith('.md')) {
        files.push(fullPath);
      }
    }
  } catch (error) {
    console.warn(`Could not read directory ${dirPath}:`, error.message);
  }

  return files;
}

async function updateLocalFile(filePath, urlMapping, dryRun = false) {
  try {
    const content = await readFile(filePath, 'utf-8');
    const { content: updatedContent, replacements } = updateMarkdownContent(
      content,
      urlMapping,
    );

    if (replacements === 0) {
      return { updated: false, replacements: 0 };
    }

    const relativePath = filePath.replace(process.cwd(), '').replace(/^\//, '');
    console.log(`üìù ${relativePath}: ${replacements} URL(s) updated`);

    if (!dryRun) {
      await writeFile(filePath, updatedContent, 'utf-8');
    }

    return { updated: true, replacements };
  } catch (error) {
    console.error(`‚ùå Failed to update ${filePath}:`, error.message);
    return { updated: false, replacements: 0, error: error.message };
  }
}

function showUsage() {
  console.log(`
Usage: node scripts/update-frontmatter-local.js <ocobo-posts-path> [options]

Arguments:
  <ocobo-posts-path>    Path to local ocobo-posts repository

Options:
  --dry-run            Show what would be changed without making changes

Examples:
  node scripts/update-frontmatter-local.js ../ocobo-posts
  node scripts/update-frontmatter-local.js /path/to/ocobo-posts --dry-run

Prerequisites:
  1. Clone ocobo-posts repository locally:
     git clone https://github.com/wab/ocobo-posts.git
  
  2. Run migration script first:
     node scripts/migrate-to-blob.js
`);
}

async function main() {
  const args = process.argv.slice(2);

  if (args.length === 0 || args.includes('--help') || args.includes('-h')) {
    showUsage();
    process.exit(0);
  }

  const repoPath = args[0];
  const dryRun = args.includes('--dry-run');

  if (!repoPath) {
    console.error('‚ùå Please provide the path to ocobo-posts repository');
    showUsage();
    process.exit(1);
  }

  if (dryRun) {
    console.log('üß™ Running in DRY RUN mode - no changes will be made\n');
  } else {
    console.log('üîÑ Starting local frontmatter update process...\n');
  }

  // Verify the repository path exists
  try {
    const stats = await stat(repoPath);
    if (!stats.isDirectory()) {
      console.error('‚ùå Provided path is not a directory');
      process.exit(1);
    }
  } catch (_error) {
    console.error('‚ùå Repository path does not exist:', repoPath);
    console.log('Please clone the ocobo-posts repository first:');
    console.log('git clone https://github.com/wab/ocobo-posts.git');
    process.exit(1);
  }

  // Load URL mapping
  const urlMapping = await loadUrlMapping();
  const mappingCount = Object.keys(urlMapping).length;
  console.log(`üìã Loaded ${mappingCount} URL mappings\n`);

  if (mappingCount === 0) {
    console.log('No URL mappings found. Nothing to update.');
    return;
  }

  try {
    // Find all markdown files in the repository
    console.log('üîç Finding markdown files...');
    const files = await findMarkdownFiles(repoPath);
    console.log(`Found ${files.length} markdown files\n`);

    if (files.length === 0) {
      console.log('No markdown files found in repository.');
      return;
    }

    // Update files
    let totalUpdated = 0;
    let totalReplacements = 0;
    const errors = [];

    for (const file of files) {
      const result = await updateLocalFile(file, urlMapping, dryRun);

      if (result.updated) {
        totalUpdated++;
      }

      totalReplacements += result.replacements;

      if (result.error) {
        errors.push({ file, error: result.error });
      }
    }

    // Summary
    console.log('\n‚úÖ Update process completed!');
    console.log(`\nüìä Summary:`);
    console.log(`- Files processed: ${files.length}`);
    console.log(`- Files updated: ${totalUpdated}`);
    console.log(`- Total URL replacements: ${totalReplacements}`);
    console.log(`- Errors: ${errors.length}`);

    if (errors.length > 0) {
      console.log('\n‚ùå Errors encountered:');
      errors.forEach(({ file, error }) => {
        console.log(`  - ${file}: ${error}`);
      });
    }

    if (dryRun && totalReplacements > 0) {
      console.log('\nüöÄ To apply changes, run without --dry-run flag');
    } else if (!dryRun && totalUpdated > 0) {
      console.log('\nüìù Next steps:');
      console.log(`1. Review the changes: cd ${repoPath} && git diff`);
      console.log(
        `2. Create a new branch: git checkout -b update-asset-urls-to-vercel-blob`,
      );
      console.log(
        `3. Commit the changes: git add . && git commit -m "Update asset URLs to Vercel Blob"`,
      );
      console.log(
        `4. Push and create PR: git push origin update-asset-urls-to-vercel-blob`,
      );
      console.log('\nüéâ All asset URLs have been updated locally!');
    }
  } catch (error) {
    console.error('\n‚ùå Update process failed:', error);
    process.exit(1);
  }
}

// Handle unhandled rejections
process.on('unhandledRejection', (reason, promise) => {
  console.error('Unhandled Rejection at:', promise, 'reason:', reason);
  process.exit(1);
});

main();
