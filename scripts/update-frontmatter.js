#!/usr/bin/env node

/**
 * Updates frontmatter in ocobo-posts repository to use Vercel Blob URLs
 * Prerequisites: pnpm add @octokit/rest
 * Run: node scripts/update-frontmatter.js
 */

import { join } from 'path';
import { dirname } from 'path';
import { fileURLToPath } from 'url';
import { Octokit } from '@octokit/rest';
import { readFile } from 'fs/promises';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Load the asset URL mapping generated by migrate-to-blob.js
const mappingPath = join(__dirname, 'asset-url-mapping.json');

// GitHub configuration
const GITHUB_ACCOUNT = process.env.GITHUB_ACCOUNT || 'your-account';
const GITHUB_REPO = process.env.GITHUB_REPO || 'ocobo-posts';
const GITHUB_TOKEN = process.env.GITHUB_ACCESS_TOKEN;

async function loadUrlMapping() {
  try {
    const mappingData = await readFile(mappingPath, 'utf-8');
    return JSON.parse(mappingData);
  } catch (error) {
    console.error('âŒ Failed to load URL mapping file:', error.message);
    console.log(
      'Make sure to run migrate-to-blob.js first to generate the mapping file',
    );
    process.exit(1);
  }
}

function updateMarkdownContent(content, urlMapping) {
  let updatedContent = content;
  let replacements = 0;

  // Update image references in frontmatter and content
  for (const [oldUrl, newUrl] of Object.entries(urlMapping)) {
    const regex = new RegExp(
      oldUrl.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'),
      'g',
    );
    const matches = updatedContent.match(regex);

    if (matches) {
      updatedContent = updatedContent.replace(regex, newUrl);
      replacements += matches.length;
    }
  }

  return { content: updatedContent, replacements };
}

async function fetchRepositoryFiles(octokit, path = '') {
  try {
    const response = await octokit.rest.repos.getContent({
      owner: GITHUB_ACCOUNT,
      repo: GITHUB_REPO,
      path: path,
    });

    const files = [];
    const dirs = [];

    for (const item of response.data) {
      if (item.type === 'file' && item.name.endsWith('.md')) {
        files.push(item);
      } else if (item.type === 'dir') {
        dirs.push(item);
      }
    }

    // Recursively fetch files from subdirectories
    for (const dir of dirs) {
      const subFiles = await fetchRepositoryFiles(octokit, dir.path);
      files.push(...subFiles);
    }

    return files;
  } catch (error) {
    console.error(`Failed to fetch files from ${path}:`, error.message);
    return [];
  }
}

async function updateFile(octokit, file, urlMapping, dryRun = false) {
  try {
    // Fetch file content
    const response = await octokit.rest.repos.getContent({
      owner: GITHUB_ACCOUNT,
      repo: GITHUB_REPO,
      path: file.path,
    });

    const content = Buffer.from(response.data.content, 'base64').toString(
      'utf-8',
    );
    const { content: updatedContent, replacements } = updateMarkdownContent(
      content,
      urlMapping,
    );

    if (replacements === 0) {
      return { updated: false, replacements: 0 };
    }

    console.log(`ðŸ“ ${file.path}: ${replacements} URL(s) updated`);

    if (!dryRun) {
      // Update file in repository
      await octokit.rest.repos.createOrUpdateFileContents({
        owner: GITHUB_ACCOUNT,
        repo: GITHUB_REPO,
        path: file.path,
        message: `Update asset URLs to Vercel Blob for ${file.name}`,
        content: Buffer.from(updatedContent).toString('base64'),
        sha: response.data.sha,
      });
    }

    return { updated: true, replacements };
  } catch (error) {
    console.error(`âŒ Failed to update ${file.path}:`, error.message);
    return { updated: false, replacements: 0, error: error.message };
  }
}

async function main() {
  console.log('ðŸ”„ Starting frontmatter update process...\n');

  // Validate environment variables
  if (!GITHUB_TOKEN) {
    console.error('âŒ GITHUB_ACCESS_TOKEN environment variable is required');
    process.exit(1);
  }

  // Load URL mapping
  const urlMapping = await loadUrlMapping();
  const mappingCount = Object.keys(urlMapping).length;
  console.log(`ðŸ“‹ Loaded ${mappingCount} URL mappings\n`);

  if (mappingCount === 0) {
    console.log('No URL mappings found. Nothing to update.');
    return;
  }

  // Initialize GitHub client
  const octokit = new Octokit({
    auth: GITHUB_TOKEN,
  });

  try {
    // Fetch all markdown files from the repository
    console.log('ðŸ” Fetching files from repository...');
    const files = await fetchRepositoryFiles(octokit);
    console.log(`Found ${files.length} markdown files\n`);

    if (files.length === 0) {
      console.log('No markdown files found in repository.');
      return;
    }

    // Ask if user wants to do a dry run first
    const args = process.argv.slice(2);
    const dryRun = args.includes('--dry-run');

    if (dryRun) {
      console.log('ðŸ§ª Running in DRY RUN mode - no changes will be made\n');
    }

    // Update files
    let totalUpdated = 0;
    let totalReplacements = 0;
    const errors = [];

    for (const file of files) {
      const result = await updateFile(octokit, file, urlMapping, dryRun);

      if (result.updated) {
        totalUpdated++;
      }

      totalReplacements += result.replacements;

      if (result.error) {
        errors.push({ file: file.path, error: result.error });
      }

      // Small delay to avoid rate limiting
      await new Promise((resolve) => setTimeout(resolve, 100));
    }

    // Summary
    console.log('\nâœ… Update process completed!');
    console.log(`\nðŸ“Š Summary:`);
    console.log(`- Files processed: ${files.length}`);
    console.log(`- Files updated: ${totalUpdated}`);
    console.log(`- Total URL replacements: ${totalReplacements}`);
    console.log(`- Errors: ${errors.length}`);

    if (errors.length > 0) {
      console.log('\nâŒ Errors encountered:');
      errors.forEach(({ file, error }) => {
        console.log(`  - ${file}: ${error}`);
      });
    }

    if (dryRun && totalReplacements > 0) {
      console.log(
        '\nðŸš€ To apply changes, run: node scripts/update-frontmatter.js',
      );
    } else if (!dryRun && totalUpdated > 0) {
      console.log('\nðŸŽ‰ All asset URLs have been updated to Vercel Blob!');
    }
  } catch (error) {
    console.error('\nâŒ Update process failed:', error);
    process.exit(1);
  }
}

// Handle unhandled rejections
process.on('unhandledRejection', (reason, promise) => {
  console.error('Unhandled Rejection at:', promise, 'reason:', reason);
  process.exit(1);
});

main();
